import {Callout} from 'nextra/components'

# Struktury danych

## Typy struktur

1. **Struktura jednostkowa/pusta** (ang. *unit-like structure*) 
    ```rust copy
    struct EmptyStructure; 

    fn main() {
        let es = EmptyStructure;
    }
    ```
1.  Czy i w jakim celu mo偶emy definiowa takie struktury?
1. **Struktura a'la krotka** (ang. *tuple structure*)
    ```rust copy
    struct Color(i32, i32, i32); // fields are without names (are access as in tuple)
    struct Point(i32, i32, i32); // a different structure with the same types

    fn main() {
        let black = Color(0, 0, 0);
        let origin = Point(0, 0, 0);
    }
    ```
1. Po prostu **struktura** :
    ```rust copy
    struct Point {
        x : f32,    // named attributes like in classes
        y : f32,
    }
    ```


## Tworzenie instancji struktury

1. W przykadowym projekcie, w katalogu `examples` dodaj plik `rectangle.rs`.
1. Otw贸rz powy偶szy plik, a w nim utw贸rz struktur danych opisujc prostokt:
    ```rust copy
    #[derive(Debug)] // allows to print the structure in debug mode (ie. to use {:?})
    struct Rectangle {
        x : f32,
        y : f32
    }
    ```
1. Dodaj metod `main`, w kt贸rej utw贸rz now instancj struktury `Rectangle` i wypisz j na konsole:
    ```rust copy
    fn main() {
        let r = Rectangle{x: 1.0, y: 2.0}; // create a new instance using constructor

        println!("{:?}", r);
        
        println!("x: {}, y: {}", r.x, r.y); // access particular fields using . operator
    }
    ```
1. Skompiluj kod i uruchom przykad:
    ```copy
    cargo run --example rectangle
    ```

1. Mo偶esz r贸wnie偶 utworzy instancje na bazie innej instancji (poni偶szy kod dopisz do funkcji `main` z poprzedniego punktu)
    ```rust copy
    let r2 = Rectangle{x : 5, ..r1} // the rest of r2 parameters are copied from r1
    println!("{:?}", r);
    println!("x: {}, y: {}", r2.x, r2.y);
    ```

<Callout type="info">
Atrybuty struktur danych, w kontekcie posiadania wartoci, zachowuj si w analogicznych spos贸b jak zmienne. 

Jeli atrybut jest typu, kt贸ry posiada dan warto (ang. *owned type*), to wano tej wartoci nale偶y do instancji struktury. Oznacza to, 偶e warto ta zostanie usunita z pamici w sytuacji, kiedy instancja struktury wyjdzie poza zakres.

Jeli natomist atrybut struktury jest referencj, to konieczne bdzie okrelenie czasu 偶ycia takiej wartoci - o czym bdzie wicej w sekcji [Czas 偶ycia](03-structures/03-lifecycle).
</Callout>

## Dostp i modyfikacja atrybut贸w

1. Instancja niemutowalna - wszystkie atrybuty s niemutowalne
    ```rust copy
    let r3 = Rectangle{x : 5.0, y : 9.0};
    println!("[{}, {}]", r3.x, r3.y);
    ```
1. Pr贸ba ustawienia wartoci atrubutu
    ```rust copy
    r3.x = 6.0; // error
    ```
1. Instacja mutowalna
    ```rust copy
    let mut r4 = Rectangle{x : 5.0, y : 9.0};
    println!("[{}, {}]", r4.x, r4.y);
    r4.x = 6.0;
    r4.y = 7.0;
    println!("[{}, {}]", r4.x, r4.y);
    ```

Mutowalno struktury (na poziomie tworzenia nowej instancji). Nie mo偶na ustawia mutowalnoci pojedynczych p贸l struktury.

## Metody

### Metody instancyjne 

1. Pod definicj struktury `Rectangle` dodaj blok bdcy miejscem implementacji metod zwizanych z nasz struktur
    ```rust copy
    impl Rectangle {
        // the place for rectangle methods
    }
    ```
1. **Wewntz** powy偶szego bloku zdefiniuje metod obliczajc pole prostokta. 
    ```rust copy
    fn area(&self) -> f32 {
        self.x * self.y
    }
    ```
    <Callout type="info">
    Zwr贸 uwage na pierwszy parametr metody (`&self`), kt贸ry oznacza referencj do instancji struktury (musi to by zawsze pierwszy parametr metod instancyjnej). Referencj `self` mo偶esz wykorzysta w ciele metody, aby odwoa si do p贸l instancji struktury lub innych metod instancyjnych.
    </Callout>
1. W funkcji `main` dodaj kod, kt贸ry wywoa metod `area` na stworzonej wczeniej instrancji `Rectangle`
    ```rust copy
    println!("Area of {:?} is {}", r, r.area());
    ```
1. W analogiczny spos贸b dodaj metod wyznaczajc obw贸d prostokta.

1. Dodaj metod umo偶liwiajc przeskalowanie prostokta o zadany wsp贸czynnik.  
    ```rust copy
    fn scale(&mut self, factor:f32) {
        self.x = self.x * factor;
        self.y = self.y * factor;
    }
    ```
    <Callout type="info">
    Zwr贸 uwag na pierwszy parametr metody (`&mut self`), kt贸ry oznacza, 偶e metoda ta bdzie modyfikowa instancj struktury.
    </Callout>
1. W metodzie `main` utw贸rz now instancj i wywoaj na ni metod `scale`:
    ```rust copy
    let r = Rectangle{ x : 5.0, y : 4.0};
    r.scale(2.0);
    println!("Area of r is {}", r.area());
    ```
1. Czy kod si skompilowa? Dlaczego?
1. Jak poprawi powy偶szy przykad?

### Metody powizane

1. W bloku `impl` utw贸rz metod `new_square`, kt贸ry utworzy nowy kwadrat (metody tego typu nazywane s metodami fabrycznymi). Blok ten powinien wyglda nastpujco:
    ```rust copy
    impl Rectangle {
        // ... other methods
        
        fn new_square(x : f32) -> Rectangle { // there is no self in the argument list
            Rectangle{x : x, y : x}
        }
    }
    ```
1. Metody powizane wywoujemy za pomoc nazwy struktury, a nastpnie dw贸ch znak贸w dwukropka, w naszym przypadku bdzie to `Rectangle::new_square`. W metodzie `main` utw贸rz nowy kwadrat i wydrukuj "go" na konsol:
    ```rust copy
    let square = Rectangle::new_square(5.0);
    println!("square: {:?}", square);
    ```
1. Mo偶esz uproci metod `new_square` wykorzystujc regu, pozwalajc na automatyczne przypisane parametru funkcji do parametru tworzonej instancji struktury o tej samej nazwie:
    ```rust copy
    fn new_square(x : f32) -> Rectangle {
        Rectangle{x, y : x} // the first argument can be passed in simplified form
    }
    ```






