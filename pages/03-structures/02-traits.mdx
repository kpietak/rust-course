import {Callout} from 'nextra/components'

# Cechy (traits)

## Definicja i implementacja cechy

1. W pliku z poprzedniego ćwiczenia `rectangle.rs`, zdefiniuj nową cechę (ang. *trait*) określającą wspólne (sic!) cechy dla wszystkich dwuwymiarowych figur geometrycznych (trait `Shape`). Na początku pliku dodaj następujący fragment kodu:
    ```rust copy
    trait Shape {
        fn area(&self) -> f32;
        fn perimeter(&self) -> f32;
    }
    ```
1. Następnie dodaj zdefiniowaną cechę do strutktury `Rectangle`. W tym celu musisz utworzyć nowy blok `impl`, którym dodasz własne implementacje zdefiniowanych metod:
    ```rust copy
    impl Shape for Rectangle {
        fn area(&self) -> f32 {
            self.x * self.y
        }

        fn perimeter(&self) -> f32 {
            2f32 * (self.x + self.y)
        }
    }
    ```
1. Dodaj do funkcji `main` kod, który wywoła nowe metody na utworzynych instancja prostokątów. Sprawdź czy wszystko działa poprawnie.

    <Callout type="default">
    Zauważyłaś/eś, że struktura `Rectangle` ma teraz dwie metody `area`? Która metoda została wywołana w metodzie `main`? 
    </Callout>

    <Callout type="info">
    Cechy mogą rozszerzać funkcje naszych struktur, mogą być również dodawane do istniejących struktur. Istnieje tylko jedna zasada: możemy zaimplementować cechę na typie tylko wtedy, gdy przynajmniej jedna z cech lub typ jest lokalny, tzn. zdefiniowany w aktualnej skrzynce (ang. *crate*). Na przykład, możemy zaimplementować standardowe cechy biblioteczne, takie jak `Display`, na niestandardowym typie, takim jak `Rectangle`, jako część funkcjonalności naszej bibliteki, ponieważ typ `Rectangle` jest lokalny. Możemy również zaimplementować `Shape` na `Vec<T>` w naszej skrzynce, ponieważ cecha `Shape` jest lokalna.

    Nie możemy jednak implementować zewnętrznych cech na zewnętrznych typach. Na przykład, nie możemy zaimplementować cechy `Display` na `Vec<T>` w naszej skrzynce, ponieważ `Display` i `Vec<T>` są zdefiniowane w bibliotece standardowej i nie są lokalne dla naszej skrzynki. Reguła ta zapewnia, że kod innych osób nie może zepsuć twojego kodu i odwrotnie. Bez tej reguły dwie skrzynki mogłyby zaimplementować tę samą cechę dla tego samego typu, a Rust nie wiedziałby, której implementacji użyć.
    </Callout>


### Domyślna implementacja metody

### Operatory
https://doc.rust-lang.org/rust-by-example/trait/ops.html

https://doc.rust-lang.org/core/ops/