---
description: "Sekcja opisuje zasady definiowania zmiennych w Rust, w tym zmienne niemutowalne, mutowalne oraz mechanizm nadpisywania zmiennych (shadowing). Dodatkowo omawia r贸偶nice pomidzy zmiennymi a staymi, takie jak konieczno okrelenia typu dla staych i ich niemutowalno. W treci znajduj si przykady kodu ilustrujce omawiane zagadnienia oraz odnoniki do dokumentacji jzyka Rust."
---

import {Callout} from 'nextra/components'

# Zmienne i stae

<Callout type="warning">
**Uwaga**

Fragmenty kodu podawane w konspekcie nale偶y przepisa lub wklei do rodka metody `main`. Dotyczy to wszystkich fragment贸w, kt贸re nie zawieraj kontekstu metody, struktury lub jasno nie wskazano, 偶e maj by wpisane do danego pliku.
</Callout>

## Zmienne i ich przesanianie
Domylnie wszystkie zmienne s niemutowalne (*immutable*), ale mog by przesaniane (*shadowed*). Nazwy zmiennych s definiowane zgodnie z konwencj `snake_case`.

### Zmienne niemutowalne

1. Zdefiniuj now zmienn cakowita i wypisz jej warto:

    ```rust copy
    let number : u32 = 12;
    println!("{}", number);
    ```
1. **Inferencja typu**: Mo偶esz pomina definicj typu, jeli kompilator bdzie w stanie wywnioskowa typ zmiennej 
    ```rust copy
    let number = 12; // type inference
    println!("{}", number);
    ```

1. Spr贸buj przypisa now warto do zmiennej:
    ```rust {2}
    let number : u32 = 12;
    number = 6; // error, cannot assign a new value to an unmutable variable
    println!("{}", number);
    ```

### Nadpisywanie zmiennych

1. Nadpisywanie zmiennych (ang. *variables shadowing*) polega na utworzeniu nowej zmiennej o takiej samej nazwie jak zdeklarowana wczeniej zmienna. Poprzednia zmienna jest usuwana z bie偶cego kontekstu.

    ```rust copy {3}
    let spaces = "    "; // &str

    let spaces = spaces.len(); // spaces variable now points to len of text and its type is usize

    println!("Size of spaces is {}", spaces);
    ```

1.  Jak wartoci wypisze poni偶szy kod? Wyjanij dlaczego? (zastan贸w sinad odpowiedzi zanim uruchomisz kod)

    ```rust copy
    fn main() { 
        let x = 5; 
        let x = x + 1; 
        { 
            let x = x * 2; 
            println!("The value of x in the inner scope is: {}", x); 
        } 
        
        println!("The value of x is: {}", x); }
    ```

{/* TODO: define here a simple verification, based on https://nextra.site/docs/guide/markdown*/}

### Zmienne mutowalne

1. Zdefiniuj zmienn mutowaln za pomoc sowa kluczowego `mut`

    ```rust copy
    let mut number : u32 = 12;
    number = 6;

    println!("{}", number);
    ```

<Callout type="info">
**Chcesz wiedzie wicej?**

Dokumentacja Rust: [Variables and mutability](https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html)

**Zmienne mutowalne vs. redefiniowanie zmiennych**

Redefiniowanie zmiennych (ang. *shadowing*), w odr贸偶nieniu od zmiennej mutowalnej, spowoduje bd kompilacji, jeli przypadkowo spr贸bujemy przypisa do niej now warto bez u偶ycia sowa kluczowego `let`. 

Ponadto w przypadku redefinicji zmiennej mo偶emy zmieni jej typ - w praktyce tworzona jest nowa zmienna wic nie ma przeciwskaza, aby posiadaa inny typ.

</Callout>

## Stae
```rust copy
const DB_PORT : u32 = 5432;
```

1. Zgoodnie z konwencj nazwy staych pisane s du偶ymi literami (`SCREAMING_SNAKE_CASE`).
1. R贸偶nice pomidzy zmiennymi i staymi:
    - stae nie mog by mutowalne (sic!)
    - przy definicji staej zawsze nale偶y poda typ wartoci
    - stae mog by zdefiniowane w dowolnym zasigu, r贸wnie偶 w zasigu globalnym,
    - wartoci staej mo偶e by tylko stae wyra偶enie, kt贸rego warto jest znana na etapie kompilacji

<Callout type="info">
**Chcesz wiedzie wicej?**

Dokumentacja Rust: [Constant evaluation](https://doc.rust-lang.org/reference/const_eval.html)
</Callout>