import {Callout} from 'nextra/components'

# Przenoszenie wasnoci wartoci

## Move 
1. Przepisz poni偶szy kod, w kt贸rym warto zmiennej `s1` jest przypisywana do zmiennej `s2`. Zgodnie z zasad o jednym wacicielu, warto zostaje "przeniesiona" (ang. *moved*), do zmiennej `s2`, kt贸ra staje si jej nowym wacicielem. Zmienna `s1` wychodzi poza zakres i nie mo偶e by wykorzystana poni偶ej linii 3.

    ```rust showLineNumbers {3} copy
    fn main() {
        let s1 = String::from("sample");
        let s2 = s1;
        
        println!("{}", s2);
        // println!("{}", s1); // error, the value is invalid
    }
    ```
1. Odkomentuj w powy偶szym kodzie lini 6 i zobacz bd kompilatora.
1. Zamie zmienn typu `String` na wartocakowit i spr贸buj wypisa obie wartoci.
    
    ```rust copy
    fn main() {
        let a = 6;
        let b = a;
        
        println!("{}", a);
        println!("{}", b); 
    }
    ```
    <Callout type="default">
    Czy kod si kompiluje i uruchamia? Dlaczego?
    </Callout>
    <Callout type="info">
    Wicej na temat pytkiego kopiowania wartoci oraz typie `Copy` znajdziesz w dalszych czciach konspektu.
    </Callout>
1. Gboka kopia (ang. *deep copy*) wartoci przechowywanych na stercie - metoda `clone`.
    ```rust copy showLineNumbers {3} 
    fn main() {
        let s1 = String::from("sample");
        let s2 = s1.clone();
        
        println!("{}", s2);
        println!("{}", s1); // we have two copies of "sample" text at a heap
    }
    ```

## Posiadanie a funkcje

1. Uruchom poni偶szy kod
    ```rust copy showLineNumbers {10}
    fn main() {
        let n = 5;
        
        process_number(n);
        process_number(n+1);

        let text = String::from("sample");
        
        process_text(text);
        // process_text(text);
    }

    fn process_text(s : String) {
        println!("Processing text: {}", s);
    }

    fn process_number(n : i32) {
        println!("Processing number: {}", n)
    }
    ```
1. Odkomentuj lini 10 (`process_text(text)`) i uruchom program.
1.  Wyjanij dlaczego kod si nie kompiluje.
1. Popraw kod, 偶eby uruchomi si poprawnie.

## Zwracanie wartoci z funkcji 

1. Warto zwracana przez funkcj przekazywana jest w posiadanie zmiennej, kt贸ra jest przypisywana do jej rezultatu
    ```rust copy
    fn main() {
        let s1 = create_text();
        println!("{}", s1);
    }

    fn create_text() -> String {
        String::from("text created inside a function")
    }
    ```
1. T wasno mo偶na wykorzysta do przetwarzania wartoci w danej funkcji
    ```rust copy
    fn main() {
        let s1 = String::from("sample text");
        let s2 = process_text(s1);
        println!("{}", s2);
    }

    fn process_text(s: String) -> String {
        s.to_uppercase()
    }
    ```
1.  Jak zaimplementowa funkcj, kt贸rej zadaniem jest przetworzenie wicej ni偶 jednej wartoci?