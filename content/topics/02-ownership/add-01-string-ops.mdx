import { Callout } from 'nextra/components'

# Operacje na acuchach znak贸w

Podstawowym (ale nie jedynym) typem opisujcym auchy znak贸w jest typ `String` (dokumentacja typu `String` [tutaj](https://doc.rust-lang.org/std/string/struct.String.html)). Typ `String` jest dynamicznie rozszerzalnym, modyfikowalnym acuchem znak贸w, kt贸ry jest przechowywany na stercie.

Jzyk Rust wprowadza literay tekstowe, kt贸re s typu `&str`. Literay tekstowe s niemutowalne, ale mog zosta wykorzystane do stworzenia nowego acucha znak贸w typu `String`.

### Tworzenie acuch贸w znakowych

Utworzenie literau tekstowego:
```rust
let s : &str = "sample text";
```

Tworzenie nowego acucha znak贸w, na podstawie literau tekstowego:
```rust
let s = String::from("sample text");
```

Tworzenie pustego acucha znak贸w:
```rust
let mut s = String::new();
// If you have an idea of how much data the String will hold, 
// consider the with_capacity method to prevent excessive re-allocation.
let mut s = String::with_capacity(10);
```

### Kodowanie UTF-8

Wartoci typu `String` reprezentuj zawsze tekst w kodowaniu UTF-8, co upraszcza przetwarzanie tekst贸w w r贸偶nych jzykach oraz wykorzystanie znak贸w non-ASCII. 

```rust
let s = String::from("");
println!("{}", s);
println!("{}", s.len());
```

Iterowanie po znakach w acuchu znak贸w:
```rust
let s = String::from(""); 
for c in s.chars() {
    println!("{}", c);
}
```
<Callout type="warning">
Nie jest dozwolone adresowanie acuch znakowego po indeksie (`np. s[0]`), poniewa偶 znaki w UTF-8 mog zajmowa r贸偶n ilo bajt贸w.
</Callout>


```rust {4}
fn main() {
    let s = String::from("");
    for i in 0..s.len() {
        println!("{}", s[i]);  // error
    }
}
```

### Por贸wnywanie acuch贸w znak贸w

Do sprawdzenia czy dwa acuchy s takie same mo偶na wykorzysta operatory por贸wnania (`==`, `!=`).

```rust
fn main() {
    let s = String::from("hello");
    if s == "hello" {
        println!("the same");
    }
}
```

<Callout type="info">
Dla dociekliwych

Dlaczego mo偶emy por贸wna `String` z literaem tekstowym, kt贸ry jest typu `&str`?

Operator `==` jest tak naprawd funkcj powizan z cech `PartialEq` (o cechach dowiesz si p贸藕niej). Cecha ta mo偶e by zaimplementowana dla dowolnej pary typ贸w i pozwala sprawdzi czy wartoci tych typ贸w s sobie r贸wne. Dla wygody, typ `String` posiada implementacj `PartialEq` midzy innymi dla  typu `&str` i vice versa.
</Callout>


### Wybrane modyfikacje acucha znak贸w

Pamitaj, 偶e wszystkie metody, kt贸re zmieniaj acuch znak贸w wymagaj zmiennej mutowalnej oraz najczciej mutowalnej po偶yczki.

Dodawanie tekstu do acucha znak贸w za pomoc metody `push_str`:
```rust
let mut s = String::new();
s.push('a'); // append single character
s.push_str("bc"); // append another string
``` 

Zmiana rozmiaru (ucinanie) acucha znak贸w za pomoc metody `truncate`:
```rust     
let mut s = String::from("sample text");
s.truncate(6); // "sample"      
```


### Operacje na znakach

Podobnie jak w przypadku acuch贸w znakowych, do por贸wnywania pojedynczych znak贸w u偶ywamy standardowych operator贸w por贸wnania, w szczeg贸lnoci `==`, `!=`.

Sprawdzenie czy znak jest cyfr:
```rust
let c = '1';
let is_digit = c.is_digit(10);
```

Konwersja znaku na cyfr za pomoc metody `to_digit`:
```rust
let c = '1';
let n = c.to_digit(10).unwrap();
```

O metodzie `unwrap` dowiesz si wicej w rozdziale dotyczcym obsugi bd贸w. Na razie przyjmij, 偶e metoda `unwrap` zwraca warto w przypadku sukcesu, a w przypadku bdu koczy program z komunikatem o bdzie.


